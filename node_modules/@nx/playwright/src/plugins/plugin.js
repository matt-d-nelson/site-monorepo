"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodes = exports.createNodesV2 = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const devkit_1 = require("@nx/devkit");
const get_named_inputs_1 = require("@nx/devkit/src/utils/get-named-inputs");
const calculate_hash_for_create_nodes_1 = require("@nx/devkit/src/utils/calculate-hash-for-create-nodes");
const workspace_context_1 = require("nx/src/utils/workspace-context");
const minimatch_1 = require("minimatch");
const cache_directory_1 = require("nx/src/utils/cache-directory");
const js_1 = require("@nx/js");
const config_utils_1 = require("@nx/devkit/src/utils/config-utils");
const file_hasher_1 = require("nx/src/hasher/file-hasher");
const pmc = (0, devkit_1.getPackageManagerCommand)();
function readTargetsCache(cachePath) {
    return (0, fs_1.existsSync)(cachePath) ? (0, devkit_1.readJsonFile)(cachePath) : {};
}
function writeTargetsToCache(cachePath, results) {
    (0, devkit_1.writeJsonFile)(cachePath, results);
}
const playwrightConfigGlob = '**/playwright.config.{js,ts,cjs,cts,mjs,mts}';
exports.createNodesV2 = [
    playwrightConfigGlob,
    async (configFilePaths, options, context) => {
        const optionsHash = (0, file_hasher_1.hashObject)(options);
        const cachePath = (0, path_1.join)(cache_directory_1.workspaceDataDirectory, `playwright-${optionsHash}.hash`);
        const targetsCache = readTargetsCache(cachePath);
        try {
            return await (0, devkit_1.createNodesFromFiles)((configFile, options, context) => createNodesInternal(configFile, options, context, targetsCache), configFilePaths, options, context);
        }
        finally {
            writeTargetsToCache(cachePath, targetsCache);
        }
    },
];
/**
 * @deprecated This is replaced with {@link createNodesV2}. Update your plugin to export its own `createNodesV2` function that wraps this one instead.
 * This function will change to the v2 function in Nx 20.
 */
exports.createNodes = [
    playwrightConfigGlob,
    async (configFile, options, context) => {
        devkit_1.logger.warn('`createNodes` is deprecated. Update your plugin to utilize createNodesV2 instead. In Nx 20, this will change to the createNodesV2 API.');
        return createNodesInternal(configFile, options, context, {});
    },
];
async function createNodesInternal(configFilePath, options, context, targetsCache) {
    const projectRoot = (0, path_1.dirname)(configFilePath);
    // Do not create a project if package.json and project.json isn't there.
    const siblingFiles = (0, fs_1.readdirSync)((0, path_1.join)(context.workspaceRoot, projectRoot));
    if (!siblingFiles.includes('package.json') &&
        !siblingFiles.includes('project.json')) {
        return {};
    }
    const normalizedOptions = normalizeOptions(options);
    const hash = await (0, calculate_hash_for_create_nodes_1.calculateHashForCreateNodes)(projectRoot, options, context, [(0, js_1.getLockFileName)((0, devkit_1.detectPackageManager)(context.workspaceRoot))]);
    targetsCache[hash] ??= await buildPlaywrightTargets(configFilePath, projectRoot, normalizedOptions, context);
    const { targets, metadata } = targetsCache[hash];
    return {
        projects: {
            [projectRoot]: {
                root: projectRoot,
                targets,
                metadata,
            },
        },
    };
}
async function buildPlaywrightTargets(configFilePath, projectRoot, options, context) {
    // Playwright forbids importing the `@playwright/test` module twice. This would affect running the tests,
    // but we're just reading the config so let's delete the variable they are using to detect this.
    // See: https://github.com/microsoft/playwright/pull/11218/files
    delete process['__pw_initiator__'];
    const playwrightConfig = await (0, config_utils_1.loadConfigFile)((0, path_1.join)(context.workspaceRoot, configFilePath));
    const namedInputs = (0, get_named_inputs_1.getNamedInputs)(projectRoot, context);
    const targets = {};
    let metadata;
    const baseTargetConfig = {
        command: 'playwright test',
        options: {
            cwd: '{projectRoot}',
        },
        parallelism: false,
        metadata: {
            technologies: ['playwright'],
            description: 'Runs Playwright Tests',
            help: {
                command: `${pmc.exec} playwright test --help`,
                example: {
                    options: {
                        workers: 1,
                    },
                },
            },
        },
    };
    targets[options.targetName] = {
        ...baseTargetConfig,
        cache: true,
        inputs: [
            ...('production' in namedInputs
                ? ['default', '^production']
                : ['default', '^default']),
            { externalDependencies: ['@playwright/test'] },
        ],
        outputs: getOutputs(projectRoot, playwrightConfig),
    };
    if (options.ciTargetName) {
        const ciBaseTargetConfig = {
            ...baseTargetConfig,
            cache: true,
            inputs: [
                ...('production' in namedInputs
                    ? ['default', '^production']
                    : ['default', '^default']),
                { externalDependencies: ['@playwright/test'] },
            ],
            outputs: getOutputs(projectRoot, playwrightConfig),
        };
        const groupName = 'E2E (CI)';
        metadata = { targetGroups: { [groupName]: [] } };
        const ciTargetGroup = metadata.targetGroups[groupName];
        const testDir = playwrightConfig.testDir
            ? (0, devkit_1.joinPathFragments)(projectRoot, playwrightConfig.testDir)
            : projectRoot;
        // Playwright defaults to the following pattern.
        playwrightConfig.testMatch ??= '**/*.@(spec|test).?(c|m)[jt]s?(x)';
        const dependsOn = [];
        await forEachTestFile((testFile) => {
            const relativeSpecFilePath = (0, devkit_1.normalizePath)((0, path_1.relative)(projectRoot, testFile));
            const targetName = `${options.ciTargetName}--${relativeSpecFilePath}`;
            ciTargetGroup.push(targetName);
            targets[targetName] = {
                ...ciBaseTargetConfig,
                command: `${baseTargetConfig.command} ${relativeSpecFilePath}`,
                metadata: {
                    technologies: ['playwright'],
                    description: `Runs Playwright Tests in ${relativeSpecFilePath} in CI`,
                    help: {
                        command: `${pmc.exec} playwright test --help`,
                        example: {
                            options: {
                                workers: 1,
                            },
                        },
                    },
                },
            };
            dependsOn.push({
                target: targetName,
                projects: 'self',
                params: 'forward',
            });
        }, {
            context,
            path: testDir,
            config: playwrightConfig,
        });
        targets[options.ciTargetName] ??= {};
        targets[options.ciTargetName] = {
            executor: 'nx:noop',
            cache: ciBaseTargetConfig.cache,
            inputs: ciBaseTargetConfig.inputs,
            outputs: ciBaseTargetConfig.outputs,
            dependsOn,
            parallelism: false,
            metadata: {
                technologies: ['playwright'],
                description: 'Runs Playwright Tests in CI',
                nonAtomizedTarget: options.targetName,
                help: {
                    command: `${pmc.exec} playwright test --help`,
                    example: {
                        options: {
                            workers: 1,
                        },
                    },
                },
            },
        };
        ciTargetGroup.push(options.ciTargetName);
    }
    return { targets, metadata };
}
async function forEachTestFile(cb, opts) {
    const files = await (0, workspace_context_1.getFilesInDirectoryUsingContext)(opts.context.workspaceRoot, opts.path);
    const matcher = createMatcher(opts.config.testMatch);
    const ignoredMatcher = opts.config.testIgnore
        ? createMatcher(opts.config.testIgnore)
        : () => false;
    for (const file of files) {
        if (matcher(file) && !ignoredMatcher(file)) {
            cb(file);
        }
    }
}
function createMatcher(pattern) {
    if (Array.isArray(pattern)) {
        const matchers = pattern.map((p) => createMatcher(p));
        return (path) => matchers.some((m) => m(path));
    }
    else if (pattern instanceof RegExp) {
        return (path) => pattern.test(path);
    }
    else {
        return (path) => {
            try {
                return (0, minimatch_1.minimatch)(path, pattern);
            }
            catch (e) {
                throw new Error(`Error matching ${path} with ${pattern}: ${e.message}`);
            }
        };
    }
}
function getOutputs(projectRoot, playwrightConfig) {
    function getOutput(path) {
        if (path.startsWith('..')) {
            return (0, path_1.join)('{workspaceRoot}', (0, path_1.join)(projectRoot, path));
        }
        else {
            return (0, path_1.join)('{projectRoot}', path);
        }
    }
    const outputs = [];
    const { reporter, outputDir } = playwrightConfig;
    if (reporter) {
        const DEFAULT_REPORTER_OUTPUT = getOutput('playwright-report');
        if (reporter === 'html' || reporter === 'json') {
            // Reporter is a string, so it uses the default output directory.
            outputs.push(DEFAULT_REPORTER_OUTPUT);
        }
        else if (Array.isArray(reporter)) {
            for (const r of reporter) {
                const [, opts] = r;
                // There are a few different ways to specify an output file or directory
                // depending on the reporter. This is a best effort to find the output.
                if (!opts) {
                    outputs.push(DEFAULT_REPORTER_OUTPUT);
                }
                else if (opts.outputFile) {
                    outputs.push(getOutput(opts.outputFile));
                }
                else if (opts.outputDir) {
                    outputs.push(getOutput(opts.outputDir));
                }
                else if (opts.outputFolder) {
                    outputs.push(getOutput(opts.outputFolder));
                }
                else {
                    outputs.push(DEFAULT_REPORTER_OUTPUT);
                }
            }
        }
    }
    if (outputDir) {
        outputs.push(getOutput(outputDir));
    }
    else {
        outputs.push(getOutput('./test-results'));
    }
    return outputs;
}
function normalizeOptions(options) {
    return {
        ...options,
        targetName: options.targetName ?? 'e2e',
        ciTargetName: options.ciTargetName ?? 'e2e-ci',
    };
}
